<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>朱猛的博客</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 29 Jul 2019 22:31:46 +0800</pubDate>
    <lastBuildDate>Mon, 29 Jul 2019 22:31:46 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>百度HTTPS握手过程</title>
        <description>&lt;h1 id=&quot;百度https过程&quot;&gt;百度HTTPS过程&lt;/h1&gt;

 &amp;gt; 如下图所示，&lt;code class=&quot;highlighter-rouge&quot;&gt;https://www.baidu.com&lt;/code&gt;请求的抓包

&lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  首先我们看到TCP的三次握手,然后是SSL/TLS的握手流程：
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    Client Hello ： 客户端向服务端发起握手

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ClientHello.png&quot; alt=&quot;&quot; /&gt;

    该报文属于Handshake Protocol的一部分，报文内容包括随机数，客户端支持的加密算法套件，session id以及扩展部分。

    随机数会用于之后对称秘钥的计算，属于混淆的一部分

    session id 用于会话的复用，由服务端生成，首次创建为空

    加密算法套件：服务端会选择其中一个加密算法使用(包括秘钥协商算法，对称加密和hash算法)
  &lt;/li&gt;
  &lt;li&gt;
    Server Hello :

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ServerClient.png&quot; alt=&quot;&quot; /&gt;

    该报文属于Handshake Protocol的一部分,用于回复Client Hello，报文内容包括随机数，选择的加密算法套件，sessionid以及扩展部分

    随机数 ： 与客户端生成的不是同一个，用于之后的密钥生成

    session id

    加密套件： 服务端选择的加密算法，用于之后交互的加密
  &lt;/li&gt;
  &lt;li&gt;
    Certificates

    该报文属于Handshake Protocol的一部分,用于向客户端传递服务端数字证书

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_Certificates.png&quot; alt=&quot;&quot; /&gt;

    数字证书： 包含服务端信息和服务端公钥，是由服务端向第三方CA机构申请; 注意证书链的顺序，最下层证书在前（用户证书在前，上级证书在后）。发送的证书是二进制格式，并非base64之后的格式。
  &lt;/li&gt;
  &lt;li&gt;
    Server Key Exchange

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ServerKeyExchange.png&quot; alt=&quot;&quot; /&gt;

    该报文只有秘钥协商选择DHE/ECDHE时，才会发送
秘钥协商算法选择RSA，不会发送。

    具体差异参看 ；&lt;a href=&quot;https://blog.csdn.net/mrpre/article/details/78025940&quot;&gt;TLS/SSL 协议详解 (30) SSL中的RSA、DHE、ECDHE、ECDH流程与区别&lt;/a&gt;

    baidu这里采用的是ECDHE算法，主要包括椭圆曲线类型和公钥，用于主秘钥的计算；这里数字证书中的秘钥就不参与主秘钥的协商了
  &lt;/li&gt;
  &lt;li&gt;
    Server Hello Done

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ServerHelloDone.png&quot; alt=&quot;&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    Client Key Exchange

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ClientKeyExchange.png&quot; alt=&quot;&quot; /&gt;

    该报文只有秘钥协商选择DHE/ECDHE时，才会发送
秘钥协商算法选择RSA，不会发送。
  &lt;/li&gt;
  &lt;li&gt;
    Change Cipher Spec

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ChangeCipherSpec.png&quot; alt=&quot;&quot; /&gt;

    这是一个无关紧要的数据。在TLS1.3中就被废弃了(可以发送、也可以不发送)。

    需要注意的是，该数据本身不被计算握手摘要，因为它的type不是Handshake。
  &lt;/li&gt;
  &lt;li&gt;
    Encrypted HandShake Message

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_EncryptedHandShakeMessage.png&quot; alt=&quot;&quot; /&gt;

    这个报文的目的就是告诉对端自己在整个握手过程中收到了什么数据，发送了什么数据。来保证中间没人篡改报文。

    其次，这个报文作用就是确认秘钥的正确性。因为Encrypted handshake message是使用对称秘钥进行加密的第一个报文，如果这个报文加解密校验成功，那么就说明对称秘钥是正确的。
  &lt;/li&gt;
  &lt;li&gt;
    Application Data

    &lt;img src=&quot;/public/pageImage/Network/HTTP/百度Https抓包_ApplicationData.png&quot; alt=&quot;&quot; /&gt;

    该报文就是实际的HTTP报文内容，已经被主秘钥加密；另外可以看到该报文不属于握手协议，而是Application_data_protocol http-over-tls
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 22 Jul 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/22/HTTPS-WITH_BAIDU/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/22/HTTPS-WITH_BAIDU/</guid>
        
        <category>HTTP</category>
        
        
        <category>TCP/IP</category>
        
      </item>
    
      <item>
        <title>HTTPS 概述</title>
        <description>&lt;h1 id=&quot;https&quot;&gt;HTTPS&lt;/h1&gt;

&lt;blockquote&gt;
  由于HTTP报文在网路上是以明文的方式传递的，因此很多时候在安全方面无法满足商用的要求，无法保证数据不被中间人截取和篡改(中间人攻击)。
&lt;/blockquote&gt;

&lt;h2 id=&quot;对称加密&quot;&gt;对称加密&lt;/h2&gt;

&lt;blockquote&gt;
  我们可以使用对称加密技术(DES,3DES,AES)对HTTP报文进行加密；AES加密技术是现在最流行且有效的加密算法，可以可靠的保证密文不被中间人解析，只要对称秘钥不泄漏。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  如果中间人截取了对称秘钥，完全可以换成自己的秘钥传递给另一端，这样就不能解决中间人攻击。那么问题就变为怎么安全的传递对称秘钥？
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Network/HTTP/HTTPS对称加密.png&quot; alt=&quot;对称加密的问题&quot; /&gt;

&lt;blockquote&gt;
  这个时候我们可以非对称加密技术加密对称秘钥，然后再在网路上传递
&lt;/blockquote&gt;

&lt;h2 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h2&gt;

&lt;blockquote&gt;
  非对称加密包含两个秘钥：公钥和私钥。公钥可以将私钥加密的数据明文化，私钥可以将公钥加密的数据明文化。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  首先由客户端向服务端发出握手请求；接着由服务端返回公钥；客户端受到公钥，生成加密报文用的对称秘钥，由公钥加密传递给服务端；最后服务端受到对称秘钥用私钥解析出来，之后就可以进行正常的数据交互了。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  但是这还是不能避免中间人攻击，如果中间人劫持了公钥，再生成自己的公钥传递给客户端。这样中间人和服务端建立连接，客户端和中间人建立连接，中间人攻击还是构成了。
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Network/HTTP/HTTPS-非对称加密.png&quot; alt=&quot;非对称加密的问题&quot; /&gt;

&lt;blockquote&gt;
  因此客户端必须要判断公钥的可靠性和完整性(即公钥是不是确实从服务端传递来的，而没有被篡改)；为解决这个问题，我会可以引入可靠的第三方CA机构
&lt;/blockquote&gt;

&lt;h2 id=&quot;数字证书&quot;&gt;数字证书&lt;/h2&gt;

&lt;blockquote&gt;
  CA机构即证书颁发机构，服务端会事先向CA机构申请数字证书。
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Network/HTTP/HTTPS-数字证书.png&quot; alt=&quot;数字证书的使用&quot; /&gt;

&lt;h3 id=&quot;数字证书的作用&quot;&gt;数字证书的作用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    认证正在访问的网站（是否为钓鱼网站）
  &lt;/li&gt;
  &lt;li&gt;
    保证数据的私密性和可靠性
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数字证书的申请&quot;&gt;数字证书的申请&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    首先服务端会生成自己的公钥和私钥，然后拿着&lt;strong&gt;公钥&lt;/strong&gt;和&lt;strong&gt;服务端的一些信息&lt;/strong&gt;向CA机构申请数字证书
  &lt;/li&gt;
  &lt;li&gt;
    CA机构拿着公钥和服务端信息通过Hash算法生成消息摘要，然后将消息摘要用自己的私钥加密，生成后的密文即数字签名。数字签名和原本的公钥及服务端信息组成数字证书
  &lt;/li&gt;
  &lt;li&gt;
    最后服务端拿到数字证书，等待客户端的握手请求
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;数字证书怎么保证交互的可靠性完整性及私密性&quot;&gt;数字证书怎么保证交互的可靠性，完整性及私密性&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;服务端受到握手请求后，首先会将数字证书传递给客户端&lt;/li&gt;
  &lt;li&gt;我们的电脑和浏览器中已经内置了一部分权威机构的根证书，这些根证书中包含了CA的公匙。 数字证书包含公钥，服务端信息和数字签名。客户端首先会将公钥，服务端信息通过Hash算法生成一份消息摘要；然后将数字签名用CA的公钥解密出一份消息摘要；对比两份消息摘要，如果不一致即公钥被篡改，停止握手。&lt;/li&gt;
  &lt;li&gt;HASH算法的不可逆性保证了消息摘要无法篡改，CA机构的非对称加密保证了公钥来源的可靠性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;https的握手&quot;&gt;HTTPS的握手&lt;/h2&gt;

&lt;img src=&quot;/public/pageImage/Network/HTTP/HTTPS握手流程.jpg&quot; alt=&quot;HTTPS的握手&quot; /&gt;

</description>
        <pubDate>Sun, 12 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/12/HTTPS/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/12/HTTPS/</guid>
        
        <category>HTTP</category>
        
        
        <category>TCP/IP</category>
        
      </item>
    
      <item>
        <title>OC 内存管理</title>
        <description>&lt;h1 id=&quot;oc-内存管理&quot;&gt;OC 内存管理&lt;/h1&gt;

&lt;blockquote&gt;
  OC 的内存管理是通过引用计数的机制实现。每一个OC对象都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;的无符号整数属性，当对象被创建时，&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;为1；当对象被变量持有时，&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;加1；当变量不再持有对象时，&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;减1；在&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;为0时，对象被销毁。
&lt;/blockquote&gt;

&lt;h2 id=&quot;mrc&quot;&gt;MRC&lt;/h2&gt;

&lt;blockquote&gt;
  手动管理引用计数和内存,需要手动在代码的相应地方添加内存管理的代码。
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/MemoryManagement/MRC_Method.png&quot; alt=&quot;MRC_Mehod&quot; /&gt;

手动内存管理的原则 ：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、自己生成的对象，自己持有
2、不是自己生成的对象也可以持有
3、不需要自己持有的对象时，释放
4、不是自己持有的对象，不可以释放
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/MemoryManagement/MRC_Rule.png&quot; alt=&quot;MRC_Rule&quot; /&gt;

&lt;h2 id=&quot;arc&quot;&gt;ARC&lt;/h2&gt;

&lt;blockquote&gt;
  ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化
&lt;/blockquote&gt;

&lt;blockquote&gt;
  在ARC环境下，一切内存管理代码都不可见，release，ratain，autorelease。retainCount都不可用（编译的时候会报错）,@autoreleasepool 在代码中可以使用.
&lt;/blockquote&gt;

&lt;blockquote&gt;
  我们只需要关心，是否有循环引用带来的内存泄露 及 autorelease带来的 内存峰值
&lt;/blockquote&gt;

```objc

for(int i = 0;i &amp;lt; 1000000; i++)
 {
      NSMutableString * str = [NSMutableString stringWithFormat:@”Hello world”];

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
  *  str 指向的对象不是自己生成的，该对象在生成时，会自动插入autorelease
  *  的内存管理代码; 返回时，引用计数为 1，在被str持有后引用计数 为2
  *  当一次循环闭包结束,str的声明周期结束，自动插入release代码来释放对象
  *  此时引用计数为 1 ,对象不会被销毁，内存泄露 ， 只有当autoreleasepool 调用 drain方法，同时为对象的引用计数减 1                
  **/   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

// 解决方法 ：
  for(int i = 0; i &amp;lt;　1000000; i++)
  {
        @autoreleasepool
        {
             NSMutableString * str = [NSMutableString stringWithFormat:@”Hello world”];  &lt;br /&gt;
        }
  }

</description>
        <pubDate>Thu, 09 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/09/MemoryManagement-of-OC/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/09/MemoryManagement-of-OC/</guid>
        
        <category>Objective-c</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>OC Block</title>
        <description>&lt;h1 id=&quot;block-代码块&quot;&gt;Block （代码块）&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;strong&gt;Block&lt;/strong&gt;是iOS 4 引入的C语言扩展功能，实质上是带有自动变量(局部变量)的匿名函数。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  如下，函数的定义是必须有名字的,函数可以通过函数指针来传递和调用;Block的定义不需要名字，但是需要赋给Block变量才可以使用
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 *
 * 函数的定义必须是有名字的
 **/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcpter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcpter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;／&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的定义不需要名字，然后赋给一个&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;变量&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;／&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;testBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  我们知道在函数的函数体中可以访问以下的变量：
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;在函数体中定义的局部变量&lt;/li&gt;
  &lt;li&gt;函数的参数&lt;/li&gt;
  &lt;li&gt;静态变量&lt;/li&gt;
  &lt;li&gt;静态全局变量&lt;/li&gt;
  &lt;li&gt;全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  而在Block的闭包中，不仅可以访问以上的变量，还可以访问在定义Block的闭包中可以访问的一切变量（包括self，局部变量，实例变量).这些变量就是Block可以访问的&lt;code class=&quot;highlighter-rouge&quot;&gt;自动变量&lt;/code&gt;.
&lt;/blockquote&gt;

如下图：在block中访问了局部变量，self，实例变量

&lt;img src=&quot;/public/pageImage/Objective_c/Block/test.png&quot; alt=&quot;&quot; /&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/result.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  如上图，打印了block中访问自动变量的地址，只有局部变量的地址是相同的。因此Block访问这些变量是将变量值做了一个浅拷贝，这样就没有办法修改原有的变量了。即&lt;code class=&quot;highlighter-rouge&quot;&gt;截获自动变量的瞬时值&lt;/code&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;block的实现&quot;&gt;Block的实现&lt;/h2&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现1.png&quot; alt=&quot;block_实现1&quot; /&gt;

&lt;blockquote&gt;
  如上图所示，我们在main函数中定义了一个block。接下来，我们用clang编译器命令(&lt;code class=&quot;highlighter-rouge&quot;&gt;clang -rewrite-objc main.m&lt;/code&gt;)将OC的代码翻译为C语言的实现。
&lt;/blockquote&gt;

C语言实现如下：

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现2.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;__main_block_impl_0&quot;&gt;__main_block_impl_0&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt;的定义翻译为&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl_0&lt;/code&gt;这个结构体变量的定义。&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl_0&lt;/code&gt;的结构如下：
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现3.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  在&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl_0&lt;/code&gt;结构体中包括&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;结构体变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_desc_0&lt;/code&gt;结构体指针，构造函数以及&lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;等其他变量。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;中保存的是Block的类型以及具体实现（函数指针）；&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_desc_0&lt;/code&gt;中记录的是block的附加信息；&lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;等变量保存的是block捕获的自动变量，在ARC中是强引用。
&lt;/blockquote&gt;

&lt;h3 id=&quot;__block_impl&quot;&gt;__block_impl&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;结构体如下：
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现5.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;结构中包含&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;变量，保存block的类型，所以block是一个OC对象；
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;FuncPtr&lt;/code&gt;是一个函数指针，指向Block的具体实现。可以看到该函数的参数不只有block的参数，还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_Impl_0&lt;/code&gt;指针，通过这个指针函数可以访问block的自动变量。
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现4.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;__main_block_desc_0&quot;&gt;__main_block_desc_0&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_desc_0&lt;/code&gt;结构如下，主要记录block的附加信息，包括结构体的大小，需要capture和dispose的变量列表
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现6.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;自动变量&quot;&gt;自动变量&lt;/h3&gt;

&lt;blockquote&gt;
  Block捕获的自动变量，会保存的在&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;结构体中。
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    对于基本数据类型，是将值拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;结构体中，所以在Block中就无法访问原来的变量了。
  &lt;/li&gt;
  &lt;li&gt;
    在ARC中，捕获的OC对象是通过强引用保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;结构体中，因此需要注意引用循环的问题。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code class=&quot;highlighter-rouge&quot;&gt;__block变量&lt;/code&gt;实质上是一种结构体，结构如下：其中&lt;code class=&quot;highlighter-rouge&quot;&gt;__forwarding&lt;/code&gt;保存的是&lt;code class=&quot;highlighter-rouge&quot;&gt;__block变量&lt;/code&gt;的地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;保存的是&lt;code class=&quot;highlighter-rouge&quot;&gt;__block变量&lt;/code&gt;的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;中会保存该结构体的指针。

    &lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现7.png&quot; alt=&quot;&quot; /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;block的类型以及内存管理&quot;&gt;Block的类型以及内存管理&lt;/h2&gt;

&lt;blockquote&gt;
  在 OC中，总共由三种block类型：
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    _NSGlobalBlock,全局的静态block，不会访问任何的外部变量，它的生命周期是全局的。
  &lt;/li&gt;
  &lt;li&gt;
    _NSStackBlock,保存在栈上的block，当定义block的闭包结束，就会被销毁
  &lt;/li&gt;
  &lt;li&gt;
    _NSMallocBlock,保存在堆上的block，当引用计数为0时，会被销毁。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;_nsglobalblock&quot;&gt;_NSGlobalBlock&lt;/h3&gt;

&lt;blockquote&gt;
  不访问任何自动变量的Block都是_NSGlobalBlock类型，且类型不会改变。
&lt;/blockquote&gt;

&lt;h3 id=&quot;_nsstackblock&quot;&gt;_NSStackBlock&lt;/h3&gt;

&lt;blockquote&gt;
  访问自动变量的block在定义时默认是_NSStackBlock类型，只有调用了copy类型，才会变成_NSMallocBlock类型。
&lt;/blockquote&gt;

&lt;h3 id=&quot;_nsmallocblock&quot;&gt;_NSMallocBlock&lt;/h3&gt;

&lt;blockquote&gt;
  在ARC中，当Block被定义后，传给一个OC变量，会自动调用Block的copy方法，这个时候Block就会变为_NSMallocBlock类型。在MRC，则需要手动调用Copy
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/Block的类型以及内存管理1.png&quot; alt=&quot;&quot; /&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/Block的类型以及内存管理2.png&quot; alt=&quot;&quot; /&gt;

&lt;h2 id=&quot;避免循环引用&quot;&gt;避免循环引用&lt;/h2&gt;

&lt;blockquote&gt;
  由于Block在访问自动变量时，比较容易造成循环引用。对于这个问题，需要将引用的一方变为weak，避免循环引用。
&lt;/blockquote&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__typeof__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 将引用一方变为weak&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;NSBlockOperation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSBlockOperation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addExecutionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;__strong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__typeof__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 在这里强引用一下weakself，避免在block执行过程中，weakself被销毁&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doMoreThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someOperationQueue&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;原文章地址&quot;&gt;原文章地址&lt;/h2&gt;

&lt;a href=&quot;https://github.com/ExistOrLive/DocumentForLearning/blob/master/iOS/Objective_C/Block/Block.md&quot;&gt;https://github.com/ExistOrLive/DocumentForLearning/blob/master/iOS/Objective_C/Block/Block.md&lt;/a&gt;

</description>
        <pubDate>Thu, 09 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/09/Block/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/09/Block/</guid>
        
        <category>Objective-c</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>Welcome to ExistOrLive's Blog</title>
        <description>第一篇博客</description>
        <pubDate>Sat, 05 May 2018 23:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/05/05/welcome-to-jekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/05/welcome-to-jekyll/</guid>
        
        <category>other</category>
        
        
        <category>other</category>
        
      </item>
    
  </channel>
</rss>
