<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>朱猛的博客</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 29 Jul 2019 15:44:53 +0800</pubDate>
    <lastBuildDate>Mon, 29 Jul 2019 15:44:53 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>OC 内存管理</title>
        <description>&lt;h1 id=&quot;oc-内存管理&quot;&gt;OC 内存管理&lt;/h1&gt;

&lt;blockquote&gt;
  OC 的内存管理是通过引用计数的机制实现。每一个OC对象都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;的无符号整数属性，当对象被创建时，&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;为1；当对象被变量持有时，&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;加1；当变量不再持有对象时，&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;减1；在&lt;code class=&quot;highlighter-rouge&quot;&gt;retainCount&lt;/code&gt;为0时，对象被销毁。
&lt;/blockquote&gt;

&lt;h2 id=&quot;mrc&quot;&gt;MRC&lt;/h2&gt;

&lt;blockquote&gt;
  手动管理引用计数和内存,需要手动在代码的相应地方添加内存管理的代码。
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/MemoryManagement/MRC_Method.png&quot; alt=&quot;MRC_Mehod&quot; /&gt;

手动内存管理的原则 ：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、自己生成的对象，自己持有
2、不是自己生成的对象也可以持有
3、不需要自己持有的对象时，释放
4、不是自己持有的对象，不可以释放
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/MemoryManagement/MRC_Rule.png&quot; alt=&quot;MRC_Rule&quot; /&gt;

&lt;h2 id=&quot;arc&quot;&gt;ARC&lt;/h2&gt;

&lt;blockquote&gt;
  ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化
&lt;/blockquote&gt;

&lt;blockquote&gt;
  在ARC环境下，一切内存管理代码都不可见，release，ratain，autorelease。retainCount都不可用（编译的时候会报错）,@autoreleasepool 在代码中可以使用.
&lt;/blockquote&gt;

&lt;blockquote&gt;
  我们只需要关心，是否有循环引用带来的内存泄露 及 autorelease带来的 内存峰值
&lt;/blockquote&gt;

```objc

for(int i = 0;i &amp;lt; 1000000; i++)
 {
      NSMutableString * str = [NSMutableString stringWithFormat:@”Hello world”];

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
  *  str 指向的对象不是自己生成的，该对象在生成时，会自动插入autorelease
  *  的内存管理代码; 返回时，引用计数为 1，在被str持有后引用计数 为2
  *  当一次循环闭包结束,str的声明周期结束，自动插入release代码来释放对象
  *  此时引用计数为 1 ,对象不会被销毁，内存泄露 ， 只有当autoreleasepool 调用 drain方法，同时为对象的引用计数减 1                
  **/   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

// 解决方法 ：
  for(int i = 0; i &amp;lt;　1000000; i++)
  {
        @autoreleasepool
        {
             NSMutableString * str = [NSMutableString stringWithFormat:@”Hello world”];  &lt;br /&gt;
        }
  }

</description>
        <pubDate>Thu, 09 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/09/MemoryManagement-of-OC/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/09/MemoryManagement-of-OC/</guid>
        
        <category>Objective-c</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>OC Block</title>
        <description>&lt;h1 id=&quot;block-代码块&quot;&gt;Block （代码块）&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;strong&gt;Block&lt;/strong&gt;是iOS 4 引入的C语言扩展功能，实质上是带有自动变量(局部变量)的匿名函数。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  如下，函数的定义是必须有名字的,函数可以通过函数指针来传递和调用;Block的定义不需要名字，但是需要赋给Block变量才可以使用
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 *
 * 函数的定义必须是有名字的
 **/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcpter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;funcpter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;／&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的定义不需要名字，然后赋给一个&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;变量&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;／&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;testBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  我们知道在函数的函数体中可以访问以下的变量：
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;在函数体中定义的局部变量&lt;/li&gt;
  &lt;li&gt;函数的参数&lt;/li&gt;
  &lt;li&gt;静态变量&lt;/li&gt;
  &lt;li&gt;静态全局变量&lt;/li&gt;
  &lt;li&gt;全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  而在Block的闭包中，不仅可以访问以上的变量，还可以访问在定义Block的闭包中可以访问的一切变量（包括self，局部变量，实例变量).这些变量就是Block可以访问的&lt;code class=&quot;highlighter-rouge&quot;&gt;自动变量&lt;/code&gt;.
&lt;/blockquote&gt;

如下图：在block中访问了局部变量，self，实例变量

&lt;img src=&quot;/public/pageImage/Objective_c/Block/test.png&quot; alt=&quot;&quot; /&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/result.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  如上图，打印了block中访问自动变量的地址，只有局部变量的地址是相同的。因此Block访问这些变量是将变量值做了一个浅拷贝，这样就没有办法修改原有的变量了。即&lt;code class=&quot;highlighter-rouge&quot;&gt;截获自动变量的瞬时值&lt;/code&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;block的实现&quot;&gt;Block的实现&lt;/h2&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现1.png&quot; alt=&quot;block_实现1&quot; /&gt;

&lt;blockquote&gt;
  如上图所示，我们在main函数中定义了一个block。接下来，我们用clang编译器命令(&lt;code class=&quot;highlighter-rouge&quot;&gt;clang -rewrite-objc main.m&lt;/code&gt;)将OC的代码翻译为C语言的实现。
&lt;/blockquote&gt;

C语言实现如下：

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现2.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;__main_block_impl_0&quot;&gt;__main_block_impl_0&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt;的定义翻译为&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl_0&lt;/code&gt;这个结构体变量的定义。&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl_0&lt;/code&gt;的结构如下：
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现3.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  在&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl_0&lt;/code&gt;结构体中包括&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;结构体变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_desc_0&lt;/code&gt;结构体指针，构造函数以及&lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;等其他变量。
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;中保存的是Block的类型以及具体实现（函数指针）；&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_desc_0&lt;/code&gt;中记录的是block的附加信息；&lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;等变量保存的是block捕获的自动变量，在ARC中是强引用。
&lt;/blockquote&gt;

&lt;h3 id=&quot;__block_impl&quot;&gt;__block_impl&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;结构体如下：
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现5.png&quot; alt=&quot;&quot; /&gt;

&lt;blockquote&gt;
  可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_impl&lt;/code&gt;结构中包含&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;变量，保存block的类型，所以block是一个OC对象；
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;FuncPtr&lt;/code&gt;是一个函数指针，指向Block的具体实现。可以看到该函数的参数不只有block的参数，还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_Impl_0&lt;/code&gt;指针，通过这个指针函数可以访问block的自动变量。
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现4.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;__main_block_desc_0&quot;&gt;__main_block_desc_0&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_desc_0&lt;/code&gt;结构如下，主要记录block的附加信息，包括结构体的大小，需要capture和dispose的变量列表
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现6.png&quot; alt=&quot;&quot; /&gt;

&lt;h3 id=&quot;自动变量&quot;&gt;自动变量&lt;/h3&gt;

&lt;blockquote&gt;
  Block捕获的自动变量，会保存的在&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;结构体中。
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    对于基本数据类型，是将值拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;结构体中，所以在Block中就无法访问原来的变量了。
  &lt;/li&gt;
  &lt;li&gt;
    在ARC中，捕获的OC对象是通过强引用保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;结构体中，因此需要注意引用循环的问题。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code class=&quot;highlighter-rouge&quot;&gt;__block变量&lt;/code&gt;实质上是一种结构体，结构如下：其中&lt;code class=&quot;highlighter-rouge&quot;&gt;__forwarding&lt;/code&gt;保存的是&lt;code class=&quot;highlighter-rouge&quot;&gt;__block变量&lt;/code&gt;的地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;保存的是&lt;code class=&quot;highlighter-rouge&quot;&gt;__block变量&lt;/code&gt;的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;__main_block_impl&lt;/code&gt;中会保存该结构体的指针。

    &lt;img src=&quot;/public/pageImage/Objective_c/Block/block_实现7.png&quot; alt=&quot;&quot; /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;block的类型以及内存管理&quot;&gt;Block的类型以及内存管理&lt;/h2&gt;

&lt;blockquote&gt;
  在 OC中，总共由三种block类型：
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    _NSGlobalBlock,全局的静态block，不会访问任何的外部变量，它的生命周期是全局的。
  &lt;/li&gt;
  &lt;li&gt;
    _NSStackBlock,保存在栈上的block，当定义block的闭包结束，就会被销毁
  &lt;/li&gt;
  &lt;li&gt;
    _NSMallocBlock,保存在堆上的block，当引用计数为0时，会被销毁。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;_nsglobalblock&quot;&gt;_NSGlobalBlock&lt;/h3&gt;

&lt;blockquote&gt;
  不访问任何自动变量的Block都是_NSGlobalBlock类型，且类型不会改变。
&lt;/blockquote&gt;

&lt;h3 id=&quot;_nsstackblock&quot;&gt;_NSStackBlock&lt;/h3&gt;

&lt;blockquote&gt;
  访问自动变量的block在定义时默认是_NSStackBlock类型，只有调用了copy类型，才会变成_NSMallocBlock类型。
&lt;/blockquote&gt;

&lt;h3 id=&quot;_nsmallocblock&quot;&gt;_NSMallocBlock&lt;/h3&gt;

&lt;blockquote&gt;
  在ARC中，当Block被定义后，传给一个OC变量，会自动调用Block的copy方法，这个时候Block就会变为_NSMallocBlock类型。在MRC，则需要手动调用Copy
&lt;/blockquote&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/Block的类型以及内存管理1.png&quot; alt=&quot;&quot; /&gt;

&lt;img src=&quot;/public/pageImage/Objective_c/Block/Block的类型以及内存管理2.png&quot; alt=&quot;&quot; /&gt;

&lt;h2 id=&quot;避免循环引用&quot;&gt;避免循环引用&lt;/h2&gt;

&lt;blockquote&gt;
  由于Block在访问自动变量时，比较容易造成循环引用。对于这个问题，需要将引用的一方变为weak，避免循环引用。
&lt;/blockquote&gt;

&lt;div class=&quot;language-objc highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__typeof__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 将引用一方变为weak&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;NSBlockOperation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSBlockOperation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addExecutionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;__strong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__typeof__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 在这里强引用一下weakself，避免在block执行过程中，weakself被销毁&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strongSelf&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doMoreThing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someOperationQueue&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;原文章地址&quot;&gt;原文章地址&lt;/h2&gt;

&lt;a href=&quot;https://github.com/ExistOrLive/DocumentForLearning/blob/master/iOS/Objective_C/Block/Block.md&quot;&gt;https://github.com/ExistOrLive/DocumentForLearning/blob/master/iOS/Objective_C/Block/Block.md&lt;/a&gt;

</description>
        <pubDate>Thu, 09 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/09/Block/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/09/Block/</guid>
        
        <category>Objective-c</category>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>Welcome to ExistOrLive's Blog</title>
        <description>第一篇博客</description>
        <pubDate>Sat, 05 May 2018 23:14:54 +0800</pubDate>
        <link>http://localhost:4000/2018/05/05/welcome-to-jekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/05/welcome-to-jekyll/</guid>
        
        <category>other</category>
        
        
        <category>other</category>
        
      </item>
    
  </channel>
</rss>
