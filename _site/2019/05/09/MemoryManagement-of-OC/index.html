<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>OC 内存管理</title>
    <meta name="description" content="OC 内存管理  OC 的内存管理是通过引用计数的机制实现。每一个OC对象都有一个retainCount的无符号整数属性，当对象被创建时，retainCount为1；当对象被变量持有时，retainCount加1；当变量不再持有对象时，retainCount减1；在retainCount为0时，对象被销毁。MRC...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/2019/05/09/MemoryManagement-of-OC/">
    <link rel="alternate" type="application/rss+xml" title="朱猛的博客" href="http://localhost:4000/feed.xml ">





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
    "HTML-CSS": {
      linebreaks: { automatic: true, width: "container" }
    }
});
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">朱猛的博客</a>
        <small>iOS Dev</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>Collections
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/demo/">
                        
                            <i class="fa fa-play"></i>Demo
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>OC 内存管理</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2019-05-09
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#iOS" title="Category: iOS" rel="category">iOS</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#Objective-c" title="Tag: Objective-c" rel="tag">Objective-c</a-->
        <a href="/tag/#Objective-c" title="Tag: Objective-c" rel="tag">Objective-c</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <h1 id="oc-内存管理">OC 内存管理</h1>

<blockquote>
  <p>OC 的内存管理是通过引用计数的机制实现。每一个OC对象都有一个<code class="highlighter-rouge">retainCount</code>的无符号整数属性，当对象被创建时，<code class="highlighter-rouge">retainCount</code>为1；当对象被变量持有时，<code class="highlighter-rouge">retainCount</code>加1；当变量不再持有对象时，<code class="highlighter-rouge">retainCount</code>减1；在<code class="highlighter-rouge">retainCount</code>为0时，对象被销毁。</p>
</blockquote>

<h2 id="mrc">MRC</h2>

<blockquote>
  <p>手动管理引用计数和内存,需要手动在代码的相应地方添加内存管理的代码。</p>
</blockquote>

<p><img src="/public/pageImage/Objective_c/MemoryManagement/MRC_Method.png" alt="MRC_Mehod" /></p>

<p>手动内存管理的原则 ：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1、自己生成的对象，自己持有
2、不是自己生成的对象也可以持有
3、不需要自己持有的对象时，释放
4、不是自己持有的对象，不可以释放
</code></pre></div></div>

<p><img src="/public/pageImage/Objective_c/MemoryManagement/MRC_Rule.png" alt="MRC_Rule" /></p>

<h2 id="arc">ARC</h2>

<blockquote>
  <p>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化</p>
</blockquote>

<blockquote>
  <p>在ARC环境下，一切内存管理代码都不可见，release，ratain，autorelease。retainCount都不可用（编译的时候会报错）,@autoreleasepool 在代码中可以使用.</p>
</blockquote>

<blockquote>
  <p>我们只需要关心，是否有循环引用带来的内存泄露 及 autorelease带来的 内存峰值</p>
</blockquote>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 <span class="p">{</span>
      <span class="n">NSMutableString</span> <span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Hello world"</span><span class="p">];</span>   

    <span class="cm">/** 
      *  str 指向的对象不是自己生成的，该对象在生成时，会自动插入autorelease
      *  的内存管理代码; 返回时，引用计数为 1，在被str持有后引用计数 为2
      *  当一次循环闭包结束,str的声明周期结束，自动插入release代码来释放对象
      *  此时引用计数为 1 ,对象不会被销毁，内存泄露 ， 只有当autoreleasepool 调用 drain方法，同时为对象的引用计数减 1                
      **/</span>
  <span class="p">}</span>

  <span class="c1">// 解决方法 ：</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="err">　</span><span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
        <span class="err">@autoreleasepool</span>
        <span class="p">{</span>
             <span class="n">NSMutableString</span> <span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Hello world"</span><span class="p">];</span>    
        <span class="p">}</span>
  <span class="p">}</span>



  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">NSMutableString</span> <span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableString</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithFormat</span><span class="p">:</span><span class="s">@"asdasdasda"</span><span class="p">];</span>
      <span class="cm">/** 
        * 这里不会有内存泄露的问题，对象由str生成并持有 ，引用计数为 1
        * 当一次循环结束，str声明周期结束，自动插入release代码，引用计数减 1 
        * 此时对象引用计数为0，对象销毁  
        **/</span>
  <span class="p">}</span>

</code></pre></div></div>

<h3 id="变量标识符">变量标识符</h3>

<ul>
  <li>
    <p>__strong                是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。</p>
  </li>
  <li>
    <p>__weak                  声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil</p>
  </li>
  <li>
    <p>__unsafe_unretained     声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</p>
  </li>
  <li>
    <p>__autoreleasing         用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</p>
  </li>
</ul>

<h3 id="属性标识符">属性标识符</h3>

<ul>
  <li>
    <p>assign 表明 setter 仅仅是一个简单的赋值操作，通常用于基本的数值类型，例如CGFloat和NSInteger。</p>
  </li>
  <li>
    <p>strong 表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行 retain ，旧值进行 release ，然后进行赋值操作。</p>
  </li>
  <li>
    <p>weak 表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行 retain，旧值也不会进行 release， 而是进行类似 assign 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil。</p>
  </li>
  <li>
    <p>unsafe_unretained 的语义和 assign 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系。</p>
  </li>
  <li>
    <p>copy 类似于 strong，不过在赋值时进行 copy 操作而不是 retain 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。</p>
  </li>
</ul>

<h2 id="自动释放池">自动释放池</h2>

<blockquote>
  <p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送release消息的机制。当你想放弃一个对象的所有权，同时又不希望这个对象立即被释放掉（例如在一个方法中返回一个对象时），Autorelease Pool 的作用就显现出来了</p>
</blockquote>

<h3 id="使用方式">使用方式</h3>

<ul>
  <li>
    <p>由RunLoop在每次事件循环开启前创建</p>
  </li>
  <li>
    <p>NSAutoreleasePool</p>
  </li>
  <li>
    <p>@autoreleasepool</p>
  </li>
</ul>

<h3 id="自动释放池-释放的契机">自动释放池 释放的契机</h3>
<blockquote>
  <p>系统在 runloop 中创建的 autoreleaspool 会在 runloop 一个 event 结束时进行释放操作。我们手动创建的 autoreleasepool 会在 block 执行完成之后进行 drain 操作</p>
</blockquote>

<h3 id="自动释放池和返回值">自动释放池和返回值</h3>

<blockquote>
  <p>如果一个函数的返回值是指向一个对象的指针，那么这个对象肯定不能在函数返回之前进行 release，这样调用者在调用这个函数时得到的就是野指针了，在函数返回之后也不能立刻就 release，因为我们不知道调用者是不是 retain 了这个对象，如果我们直接 release 了，可能导致后面在使用这个对象时它已经成为 nil 了。</p>
</blockquote>

<blockquote>
  <p>为了解决这个纠结的问题， Objective-C 中对对象指针的返回值进行了区分，一种叫做 retained return value，另一种叫做 unretained return value。前者表示调用者拥有这个返回值，后者表示调用者不拥有这个返回值，按照“谁拥有谁释放”的原则，对于前者调用者是要负责释放的，对于后者就不需要了。</p>
</blockquote>

<blockquote>
  <p>按照苹果的命名 convention，以 alloc, copy, init, mutableCopy 和 new 这些方法打头的方法，返回的都是 retained return value，例如 [[NSString alloc] initWithFormat:]，而其他的则是 unretained return value，例如 [NSString stringWithFormat:]。我们在编写代码时也应该遵守这个 convention</p>
</blockquote>

<p>MRC中：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// retained return value:</span>
                            
 <span class="c1">// 调用者生成并持有，负责对象的释放                </span>
<span class="k">-</span> <span class="p">(</span><span class="n">MyCustomCalss</span> <span class="o">*</span><span class="p">)</span> <span class="nf">initWIthName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span> <span class="n">name</span>     <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span> <span class="p">[</span><span class="n">MyCustomClass</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>      
<span class="p">}</span>
                
<span class="c1">// unretained return value：</span>

<span class="c1">// 对象不是由调用者生成，不负责对象的释放，由autoreleasepool负责                      </span>
<span class="k">+</span> <span class="p">(</span><span class="n">MyCustomClass</span> <span class="o">*</span> <span class="p">)</span>  <span class="nf">myCustomClassWithName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span> <span class="n">name</span>           
<span class="p">{</span>                                                     
    <span class="c1">//  添加autorelease ，是为了管理 对象生成时，引用计数的 加一</span>
    <span class="k">return</span>  <span class="p">[</span> <span class="p">[</span> <span class="p">[</span><span class="n">MyCustomClass</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">]</span> <span class="nf">autorelease</span><span class="p">];</span>          
<span class="p">}</span>

</code></pre></div></div>

<p>ARC中：</p>

<p>对于这两种方法，在ARC不需要过多关注他们的区别，ARC会自动为我们插入相应的内存管理代码，但还是要了解相应的原理</p>

<p>retained return value：</p>

<p><img src="/public/pageImage/Objective_c/MemoryManagement/retained_return_value.png" alt="retained return value" /></p>

<p>对于retained return value 方法 ， ARC 会在离开方法闭包的范围前，返回值赋值的时候，持有这个对象。当从方法中接收到返回值时，ARC会释放这个对象</p>

<p>unretained return value：</p>

<p><img src="/public/pageImage/Objective_c/MemoryManagement/unretained_return_value.png" alt="unretained return value" /></p>

<p>ARC会在返回 返回值的时候，持有这个对象，然后离开局部闭包，之后当对象离开调用者生命周期的时候，释放；最坏的情况，会调用autorelease，但是调用者不能确定这个对象是否调用了autorelease
ARC虽然会做一些工作来缩短返回值的生命时间，但不会在强制调用者做额外的工作</p>

<h2 id="allocretainreleasedealloc的实现">alloc/retain/release/dealloc的实现</h2>

<blockquote>
  <p>苹果是以散列表的方式保存对象的引用计数，散列表的key为对象内存块地址的散列值，value为对象的引用计数</p>
</blockquote>

<h2 id="autoreleasepool的实现">autoreleasepool的实现</h2>

<blockquote>
  <p>在苹果的实现中，<code class="highlighter-rouge">NSAutoreleasePool</code>是保存在堆栈中的；当某个对象调用autorelease，是将该对象添加到栈顶的<code class="highlighter-rouge">NSAutoreleasePool</code></p>
</blockquote>

<h2 id="参考文档">参考文档</h2>

<p><a href="http://www.importnew.com/16433.html">Java内存管理原理及内存区域详解</a></p>

<p><a href="https://segmentfault.com/a/1190000004943276#articaleHeader6">Objective-C 内存管理——你需要知道的一切</a></p>

<h2 id="文章原地址">文章原地址</h2>
<p><a href="https://github.com/ExistOrLive/DocumentForLearning/blob/master/iOS/Objective_C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md">https://github.com/ExistOrLive/DocumentForLearning/blob/master/iOS/Objective_C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md</a></p>


        </article>
        <hr>

        
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                        
                        <h2 id="similar_posts">Similar Posts</h2>
                        <ul>
                        
                        <li class="relatedPost">
                            <a href="/2019/05/09/Block/">OC Block
                            
                            </a>
                        </li>
                        
                        
                    
                
            
        
            
            
                
                    
                
            
        
        
            </ul>
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2019/05/09/Block/">OC Block</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2019/05/12/HTTPS/">HTTPS 概述</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        


<div id="disqus_thread"></div>
<script>
    /**
     * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function() {
        this.page.url = 'http://localhost:4000/2019/05/09/MemoryManagement-of-OC/'; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://localhost:4000/2019/05/09/MemoryManagement-of-OC/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
            s = d.createElement('script');

        s.src = '//ExistOrLive.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>




    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#similar_posts">Similar Posts</a></li>
                    
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             随便谢谢 
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/ExistOrLive" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:2068531506@qq.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>        
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
